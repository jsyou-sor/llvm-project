/* TODO:
 * [0] Where to add the pass
 *      - addPass@PreEmitPass   => gets all the load (including SP referenced ones)
 * 
 * [1] Reserve X15 register
 *      - Reserved.set(AArch64::X15) && addPass@PreRegAlloc => error
 *      - markSuperRegs(Reserved, AArch64::X15) @ AArch64RegisterInfo.cpp
 * [2] Get immediates also
 *      - Or we can check/verify immediates large enough to change the tag bits are not added
 *        during memory access addressing
 * 
 * [3] Change ADD to MOV && MOV only bottom 60 bits
 *      - EXTR X15, addr, X15, 60
 *      - EXTR X15, X15, X15, 4     == ROR X15, X15, 4 (after compilation)
 * 
 * [4] Exchange LD memory operand to X15 (no need for the overhead experiment)
 *      - ARMv8-A Addressing Modes
 *          + Simple:       LDR X0, [X1]
 *          + Offset:       LDR X0, [X1, #12]
 *          + Pre-index:    LDR X0, [X1, #12]!      // X1 = X1 + 12 before memory access
 *          + Post-index:   LDR X0, [X1], #12       // X1 = X1 + 12 after memory access
 *          + LD/ST Pair:   LDP X0, X1, [X2]        // X0 = [X2], X1 = [X2 + 8]
 *                          LDP X0, X1, [SP], #16   // X0 = [SP], X1 = [SP + 8], SP = SP + 16
 *
 * [5] Tag stack at function beginning
 * [6] Instrument memory access via SP
 *      - What about memory access via FP(X29)?
 */

// Change address operand to X15 (if MTE is available)

// unsigned idx = 0;
//  for (unsigned i = 0; i < MI.getNumOperands(); i++)
//    if (!MI.getOperand(i).isReg())
//      idx = i - 1;
//  MI.getOperand(idx).ChangeToRegister(AArch64::X15, 1, 0, 0, 0, 0, 0);
